from copy import deepcopy
import re
import logging

import gtk
from pygtkhelpers.utils import gsignal
from pygtkhelpers.ui.objectlist import ObjectList
from pygtkhelpers.ui.objectlist.column import Column

from .pygtkhelpers_widgets import get_type_from_schema
from .uuid_minimal import uuid4


class FieldsStep(object):
    '''
    Expose all key/value pairs specified through kwargs as object attributes. 
    This is convenient for use in combination with a pygtkhelpers ObjectList,
    since an ObjectList object uses attribute access to read/write field values.

    >>> field_step = FieldsStep(foo='Hello', bar='World')
    >>> field_step.foo
    'Hello'
    >>> field_step.bar
    'World'
    >>> field_step.attrs
    {'foo': 'Hello', 'bar': 'World'}
    '''
    def __init__(self, **kwargs):
        for key, value in kwargs.iteritems():
            setattr(self, key, value)

    def __setstate__(self, state):
        self.__dict__.update(state)

    def __getstate__(self):
        return self.__dict__

    def __getattr__(self, name):
        if not name in dir(self):
            setattr(self, name, None)
        return object.__getattribute__(self, name)

    @property
    def attrs(self):
        return dict([(k, v) for k, v in self.__dict__.items() 
                if k not in ('__members__', '__methods__',
                        '_getAttributeNames')])


class CombinedFields(ObjectList):
    '''
    Given a dictionary mapping of form names to pygtkhelpers Form instances
    create an ObjectList where each field in a form is name-mangled to prevent
    Column attribute conflicts.

    >>> from flatland import Form, String, Integer
    >>> from pprint import pprint
    >>> form1 = Form.of(String.named('my_string_field'), Integer.named('my_int_field'))
    >>> form2 = Form.of(String.named('another_string_field'), Integer.named('another_int_field'))
    >>> forms = {'example_form': form1, 'another_form': form2}

    In this example, we have two forms, each with two fields.

    >>> pprint(dict([(name, form.field_schema_mapping) for name, form in forms.items()])) # doctest:+SKIP
    {'another_form': {u'another_int_field': <class '__main__.Integer'>,
                    u'another_string_field': <class '__main__.String'>},
    'example_form': {u'my_int_field': <class '__main__.Integer'>,
                    u'my_string_field': <class '__main__.String'>}}

    Here we have a dictionary, which assigns each form a name (e.g.,
    'another_form').  Using this dictionary of Form instance values, we can
    create a CombinedFields ObjectList to construct a GTK list view showing all
    fields from all forms combined together.

    >>> combined_fields = CombinedFields(forms, enabled_attrs=None)

    Each form in the specified 'forms' is assigned a Universally Unique
    IDentifier (UUID), which is used to perform name-mangling of form field
    names.

    >>> combined_fields.uuid_mapping # doctest:+SKIP
    {'another_form': 'e4467fe0bd', 'example_form': '196ff80637'}

    Here we can see the mangled field names from both forms (compare to the
    original field names above).

    >>> pprint(combined_fields._full_field_to_field_def) # doctest:+SKIP
    {u'_196ff80637__my_int_field': <class '__main__.Integer'>,
     u'_196ff80637__my_string_field': <class '__main__.String'>,
     u'_e4467fe0bd__another_int_field': <class '__main__.Integer'>,
     u'_e4467fe0bd__another_string_field': <class '__main__.String'>}

    Given these unique field names, a pygtkhelpers.ui.objectlist.Column is
    created for each field where 'attr' is set to the unique field name.  The
    title of a Column is generated by using the original (non-mangled) name of
    each field, while replacing underscores with spaces and capitalizing the
    first word, as shown below.

    >>> pprint([(c.attr, c.title) for c in combined_fields._columns]) # doctest:+SKIP
    [(u'_e4467fe0bd__another_string_field', u'Another string field'),
     (u'_e4467fe0bd__another_int_field', u'Another int field'),
     (u'_196ff80637__my_string_field', u'My string field'),
     (u'_196ff80637__my_int_field', u'My int field')]
    '''
    field_set_prefix = '_%s__'

    gsignal('fields-filter-request', object)
    gsignal('rows-changed', object, object)
    # args: (row_id, step_data, name, value)
    gsignal('row-changed', int, object, str, object)

    def __init__(self, forms, enabled_attrs, *args, **kwargs):
        self.first_selected = True
        self.forms = forms
        self.uuid_mapping = dict([(name, uuid4().get_hex()[:10]) for name in forms])
        self.uuid_reverse_mapping = dict([(v, k) for k, v in self.uuid_mapping.items()])
        self._columns = []
        self._full_field_to_field_def = {}
        if not enabled_attrs:
            enabled = lambda form_name, field: True
        else:
            enabled = lambda form_name, field:\
                    field.name in enabled_attrs.get(form_name, {})
        for form_name, form in self.forms.iteritems():
            for f in form.field_schema:
                if not enabled(form_name, f):
                    continue
                title = re.sub(r'_', ' ', f.name).capitalize()
                prefix = self.field_set_prefix % self.uuid_mapping[form_name] 
                name = '%s%s' % (prefix, f.name)
                val_type = get_type_from_schema(f)
                d = dict(attr=name, type=val_type, title=title, resizable=True,
                        editable=True, sorted=False)
                if f.properties.get('mappers', None):
                    d['mappers'] = deepcopy(f.properties['mappers'])
                    for m in d['mappers']:
                        m.attr = '%s%s' % (prefix, m.attr)
                if val_type == bool:
                    # Use checkbox for boolean cells
                    d['use_checkbox'] = True
                elif val_type == int:
                    # Use spinner for integer cells
                    d['use_spin'] = True
                logging.debug('[CombinedFields] column attrs=%s' % d)
                self._columns.append(Column(**d))
                self._full_field_to_field_def[name] = f
        logging.debug('[CombinedFields] columns=%s' % self._columns)
        super(CombinedFields, self).__init__(self._columns, *args, **kwargs)
        s = self.get_selection()
        s.set_mode(gtk.SELECTION_MULTIPLE)
        self.connect('item-changed', self._on_item_changed)
        self.connect('item-right-clicked', self._on_right_clicked)
        self.enabled_fields_by_form_name = enabled_attrs

    def _set_rows_attr(self, row_ids, column_title, value, prompt=False):
        title_map = dict([(c.title, c.attr) for c in self.columns])
        attr = title_map.get(column_title)
        if prompt:
            from utility.gui.form_view_dialog import FormViewDialog
            from flatland import Form

            Fields = Form.of(self._full_field_to_field_def[attr])
            local_field = Fields.field_schema_mapping.keys()[0]

            temp = FormViewDialog(title='Set %s' % local_field)
            response_ok, values = temp.run(Fields,
                    {local_field: value})
            if not response_ok:
                return
            value = values.values()[0]
        else:
            title_map = dict([(c.title, c.attr) for c in self.columns])
            attr = title_map.get(column_title)

        for i in row_ids:
            setattr(self[i], attr, value)
        logging.debug('Set rows attr: row_ids=%s column_title=%s value=%s'\
            % (row_ids, column_title, value))
        self._on_multiple_changed(attr)
        return True

    def _deselect_all(self, *args, **kwargs):
        s = self.get_selection()
        s.unselect_all()

    def _select_all(self, *args, **kwargs):
        s = self.get_selection()
        s.select_all()

    def _invert_rows(self, row_ids):
        self._select_all()
        s = self.get_selection()
        for i in row_ids:
            s.unselect_path(i)

    def _get_popup_menu(self, item, column_title, value, row_ids):
        popup = gtk.Menu()
        def set_attr_value(*args, **kwargs):
            logging.debug('[set_attr_value] args=%s kwargs=%s' % (args, kwargs))
            self._set_rows_attr(row_ids, column_title, value)
        def set_attr(*args, **kwargs):
            logging.debug('[set_attr] args=%s kwargs=%s' % (args, kwargs))
            self._set_rows_attr(row_ids, column_title, value, prompt=True)
        def invert_rows(*args, **kwargs):
            self._invert_rows(row_ids)
        menu_items = []
        menu_items += [(gtk.MenuItem('Invert row selection'), invert_rows), ]
        if len(row_ids) < len(self):
            menu_items += [(gtk.MenuItem('Select all rows'), self._select_all), ]
        if len(row_ids) > 0:
            menu_items += [(gtk.MenuItem('Deselect all rows'), self._deselect_all), ]

        item_id = [r for r in self].index(item)
        if item_id not in row_ids:
            logging.debug('[ProtocolGridController] _on_right_clicked(): '\
                            'clicked item is not selected')
        elif len(row_ids) > 1:
            menu_items += [
                (gtk.MenuItem('''Set selected [%s] to "%s"'''\
                            % (column_title, value)), set_attr_value),
                (gtk.MenuItem('''Set selected [%s] to...''' % column_title),
                set_attr),
            ]
        def request_field_filter(*args, **kwargs):
            from gui.field_filter_controller import FieldFilterController

            ffc = FieldFilterController()
            response = ffc.run(self.forms, self.enabled_fields_by_form_name)
            if response == gtk.RESPONSE_OK:
                self.emit('fields-filter-request', ffc.enabled_fields_by_form_name)

        menu_items += [(gtk.MenuItem('Select fields...'), request_field_filter), ]
        for item, callback in menu_items:
            popup.add(item)
            item.connect('activate', callback)
        popup.show_all()
        return popup

    def _on_button_press_event(self, treeview, event):
        item_spec = self.get_path_at_pos(int(event.x), int(event.y))
        if item_spec is not None:
            # clicked on an actual cell
            path, col, rx, ry = item_spec
            signal_map = {
                (1, gtk.gdk.BUTTON_PRESS): 'item-left-clicked',
                (3, gtk.gdk.BUTTON_PRESS): 'item-right-clicked',
                (2, gtk.gdk.BUTTON_PRESS): 'item-middle-clicked',
                (1, gtk.gdk._2BUTTON_PRESS): 'item-double-clicked',
            }
            signal_name = signal_map.get((event.button, event.type))
            if not signal_name == 'item-right-clicked':
                self._emit_for_path(path, event)
            else:
                item = self._object_at_sort_path(path)
                return self._on_right_clicked(self, item, event, col.get_title())

    def _on_right_clicked(self, list_, item, event, column_title):
        title_map = dict([(c.title, c.attr) for c in self.columns])
        attr = title_map.get(column_title)
        selection = self.get_selection()
        model, rows = selection.get_selected_rows()
        if not rows:
            return False
        row_ids = zip(*rows)[0]
        value = getattr(item, attr)

        self.grab_focus()
        popup = self._get_popup_menu(item, column_title, value, row_ids)
        popup.popup(None, None, None, event.button, event.time)
        del popup
        return True

    def _update_fields_step(self, form_name, step_number, attrs):
        '''
        -get step values for (form_name, step_number)
        -set affected objectlist item attributes based on step values
        '''
        if form_name not in self.forms\
            or step_number >= len(self):
            return
        combined_step = self[step_number]
        form_step = combined_step.get_fields_step(form_name)

        for attr, value in attrs.items():
            setattr(form_step, attr, value)
        self.update(combined_step)

    def _on_multiple_changed(self, attr, **kwargs):
        selection = self.get_selection()
        model, rows = selection.get_selected_rows()
        row_ids = zip(*rows)[0]
        logging.debug('[CombinedFields] _on_multiple_changed(): attr=%s '\
                'selected_rows=%s' % (attr, row_ids))
        self.emit('rows-changed', row_ids, rows)

    def _on_item_changed(self, widget, step_data, name, value, **kwargs):
        row_id = [r for r in self].index(step_data)
        logging.debug('[CombinedFields] _on_item_changed(): name=%s value=%s' % (name, value))
        self.emit('row-changed', row_id, step_data, name, value)



class CombinedStep(object):
    '''
    This class provides storage for all field values for a particular row/step
    in a CombinedFields instance.  Access to the field values is provided
    through attribute access (i.e., getattr, setattr) using the CombinedFields
    mangled field name.  This provides compatibility with the pygtkhelpers
    ObjectList class (parent class of CombinedFields), which constructs a GTK
    list view based on a list of objects corresponding to the rows.

    >>> from flatland import Form, String, Integer
    >>> from pprint import pprint

    Here we create two forms, where all fields have a default value assigned.

    >>> form1 = Form.of(String.named('my_string_field').using(default='foo'))
    >>> form2 = Form.of(Integer.named('my_int_field').using(default=10))
    >>> forms = {'example_form': form1, 'another_form': form2}

    Next, we construct a CombinedFields instance based on the forms.

    >>> combined_fields = CombinedFields(forms, enabled_attrs=None)

    Using the CombinedFields object, we create a CombinedStep instance.  Note
    that if 'attributes' is None (default), all field values will be set to
    their default values (see above).

    >>> combined_step = CombinedStep(combined_fields, attributes=None)

    Here we can see that internally, the field values corresponding to each form
    are grouped together by form into a FieldsStep instance.

    >>> pprint(dict([(form_name, field_step.attrs)
    ...     for form_name, field_step in combined_step.attributes.items()]))
    {'another_form': {'my_int_field': 10},
     'example_form': {'my_string_field': u'foo'}}

    Attribute access to a CombinedStep maps to the mangled field names
    defined by the CombinedFields instance.

    >>> pprint([(c.attr, c.title) for c in combined_fields._columns]) # doctest:+SKIP
    [(u'_05c880b1f4__my_int_field', u'My int field'),
    (u'_261660f830__my_string_field', u'My string field')]

    Here we read the value of the 'my_int_field' field from the 'another_form'
    using the mangled field name.

    >>> combined_step._05c880b1f4__my_int_field # doctest:+SKIP
    10

    Note that values can also be set using the mangled field name.

    >>> combined_step._05c880b1f4__my_int_field = 1234 # doctest:+SKIP

    Here we can see that the corresponding FieldsStep instance has been updated
    to reflect the change.

    >>> pprint(dict([(form_name, field_step.attrs)
    ...     for form_name, field_step in combined_step.attributes.items()])) # doctest:+SKIP
    {'another_form': {'my_int_field': 1234},
     'example_form': {'my_string_field': u'foo'}}
    '''
    field_set_prefix = '_%s__'

    def __init__(self, combined_fields, step_id=None, attributes=None):
        self.combined_fields = combined_fields

        if attributes is None:
            self.attributes = dict()
            for form_name, form in combined_fields.forms.iteritems():
                temp = form.from_defaults()
                attr_values = dict([(k, v.value) for k, v in temp.iteritems()])
                logging.debug('[CombinedStep] attr_values=%s' % attr_values)
                self.attributes[form_name] = FieldsStep(**attr_values)
        else:
            self.attributes = attributes

    def get_fields_step(self, form_name):
        return self.attributes[form_name]
    
    def decode_form_name(self, mangled_form_name):
        return mangled_form_name.split('__')[-1]
    
    def set_step(self, step_id):
        if 'DefaultFields' in self.combined_fields.forms and step_id is not None:
            self.attributes['DefaultFields'].step = step_id

    def __getattr__(self, name):
        logging.debug('[CombinedStep] name=%r' % name)
        if not name in ['attributes', 'combined_fields']:
            for form_name, uuid_code in self.combined_fields.uuid_mapping.iteritems():
                field_set_prefix = self.field_set_prefix % uuid_code
                logging.debug('name=%s, field_set_prefix=%s' % (name, field_set_prefix))
                if name.startswith(field_set_prefix):
                    return getattr(self.attributes[form_name], name[len(field_set_prefix):])
        return object.__getattribute__(self, name)

    def __setattr__(self, name, value):
        logging.debug('[CombinedStep] set %s=%s' % (name, value))
        if not name in ['attributes', 'combined_fields']:
            for form_name, uuid_code in self.combined_fields.uuid_mapping.iteritems():
                field_set_prefix = self.field_set_prefix % uuid_code
                if name.startswith(field_set_prefix):
                    setattr(self.attributes[form_name], name[len(field_set_prefix):], value)
        self.__dict__[name] = value
        logging.debug(self.__dict__[name])

    def __str__(self):
        return '<CombinedStep attributes=%s>' % [(k, v.attrs) for k, v in self.attributes.iteritems()]





